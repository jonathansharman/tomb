import Easing;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha4;

const X_RES = $var["screen_width"];
const Y_RES = $var["screen_height"];

const BOARD_LINE_WIDTH = 2.0;
const BOARD_ROW_COUNT = 3;
const BOARD_COL_COUNT = 8;
const BOARD_TOP_LEFT_X = 125;
const BOARD_TOP_LEFT_Y = 200;
const BOARD_TOP_RIGHT_X = 675;
const BOARD_TOP_RIGHT_Y = 200;
const BOARD_BOTTOM_LEFT_X = 50;
const BOARD_BOTTOM_LEFT_Y = 400;
const BOARD_BOTTOM_RIGHT_X = 750;
const BOARD_BOTTOM_RIGHT_Y = 400;

const TURN_TRANSITION_DURATION = 20;

function drawCentered(image, x, y) {
	image.draw(x - 0.5 * image.width, y - 0.5 * image.height);
}

function lerp(p1, p2, t) {
	return [p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1])];
}

// Maps board coordinates to screen coordinates.
function boardRowColToXY(row, col) {
	rowT = 1.0 * row / BOARD_ROW_COUNT;
	start = lerp
		( [BOARD_TOP_LEFT_X, BOARD_TOP_LEFT_Y]
		, [BOARD_BOTTOM_LEFT_X, BOARD_BOTTOM_LEFT_Y]
		, rowT
		);
	end = lerp
		( [BOARD_TOP_RIGHT_X, BOARD_TOP_RIGHT_Y]
		, [BOARD_BOTTOM_RIGHT_X, BOARD_BOTTOM_RIGHT_Y]
		, rowT
		);
	colT = 1.0 * col / BOARD_COL_COUNT;
	return lerp(start, end, colT);
}

enum State
	{ PLAYER_TURN
	, TURN_TRANSITION
	}

class MainScene : AbstractScene {
	field state = State.PLAYER_TURN;
	field turnTransitionProgress;

	field mousePos;
	field board;
	field hand;

	constructor() {
		// Initialize board.
		this.board = [];
		for (row = 0; row < BOARD_ROW_COUNT; ++row) {
			this.board.add(BOARD_COL_COUNT * [null]);
		}
		// Initialize hand.
		this.hand =
			[ new Card("Destroy all cobras.")
			, new Card("Destroy all red monsters.")
			, new Card("Destroy all green monsters.")
			];
	}

	function update(inputManager, events) {
		// Update monsters.
		for (row = 0; row < BOARD_ROW_COUNT; ++row) {
			for (col = 0; col < BOARD_COL_COUNT; ++col) {
				monster = this.board[row][col];
				if (monster != null) {
					monster.animation.update();
				}
			}
		}
		switch (this.state) {
			case State.PLAYER_TURN:
				// Pass turn.
				if (inputManager.isKeyPressedThisFrame(KeyboardKey.ENTER)) {
					this.turnTransitionProgress = 0;
					this.state = State.TURN_TRANSITION;
				}
				break;
			case State.TURN_TRANSITION:
				++this.turnTransitionProgress;
				if (this.turnTransitionProgress == TURN_TRANSITION_DURATION) {
					// Shuffle monsters to the left.
					for (row = 0; row < BOARD_ROW_COUNT; ++row) {
						for (col = 0; col < BOARD_COL_COUNT - 1; ++col) {
							this.board[row][col] = this.board[row][col + 1];
						}
					}
					// Spawn new monsters in the last column.
					for (row : this.board) {
						row[-1] = Monster.spawn();
					}
					// Switch back to player control.
					this.state = State.PLAYER_TURN;
				}
				break;
		}
	}

	function render() {
		Graphics2D.Draw.fill(128, 96, 32);

		// Draw board.
		for (row = 0; row <= BOARD_ROW_COUNT; ++row) {
			start = boardRowColToXY(row, 0);
			end = boardRowColToXY(row, BOARD_COL_COUNT);
			Graphics2D.Draw.line
				( start[0], start[1]
				, end[0], end[1]
				, BOARD_LINE_WIDTH
				, 0, 0, 0
				);
		}
		for (col = 0; col <= BOARD_COL_COUNT; ++col) {
			start = boardRowColToXY(0, col);
			end = boardRowColToXY(BOARD_ROW_COUNT, col);
			Graphics2D.Draw.line
				( start[0], start[1]
				, end[0], end[1]
				, BOARD_LINE_WIDTH
				, 0, 0, 0
				);
		}
		// Draw monsters.
		easingValue = this.state == State.TURN_TRANSITION
			? EasingFunction.LINEAR.ease(0.0, 1.0, this.turnTransitionProgress, TURN_TRANSITION_DURATION)
			: 0.0
			;
		for (row = 0; row < BOARD_ROW_COUNT; ++row) {
			for (col = 0; col < BOARD_COL_COUNT; ++col) {
				monster = this.board[row][col];
				if (monster != null) {
					pos = boardRowColToXY(row + 0.5, col + 0.5 - easingValue);
					Graphics2D.Draw.ellipse(pos[0] - 18, pos[1] - 5, 36, 10, 0, 0, 0, 128);
					monster.animation.draw(pos[0], pos[1], 0.1, 0.1);
				}
			}
		}

		// Draw hand.
		for (i = 0; i < this.hand.length; ++i) {
			this.hand[i].draw(10 + i * (CARD_WIDTH + 10), Y_RES - CARD_HEIGHT - 10);
		}
	}
}
